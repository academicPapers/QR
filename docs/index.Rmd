---
title: "Regressão Quantílica"
subtitle: "Com dados imobiliários"
author: "Luiz Fernando Palin Droubi"
institute: "droubi.tech"
date: "2019/10/04 (updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: [default, cobreap.css]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: "16:9"
    seal: false
---
class: title-slide

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      fig.align = "center", out.width = "80%", fig.path = "images/",
                      eval = TRUE)
library(knitr)
library(kableExtra)
library(ggplot2)
library(ggthemes)
theme_set(theme_few())
library(qrnn)
library(tidyr)
library(appraiseR)
library(quantreg)
library(broom)
library(cowplot)
```

.pull-left[
]

.pull-right[
<br><br><br><br>
### ANÁLISE DE MODELOS DE REGRESSÃO QUANTÍLICA OBTIDOS A PARTIR DE DADOS IMOBILIÁRIOS

#### Autores:

* Carlos Augusto Zilli
* Murilo Damian Ribeiro
* Luiz Fernando Palin Droubi
* Norberto Hochheim
]


---
class: primary, center, middle

# Motivação

---
class: center, middle
background-image: url("https://statisticaloddsandends.files.wordpress.com/2019/01/growth-chart.jpg")
background-size: contain


---
class: primary
# Histórico

* Século XVIII: 
  + Boscovich
  + Laplace
* Edgeworth (1888): propõe algorítmo para obter intercepto e inclinação da reta que minimiza a soma dos resíduos absolutos
* Arrow e Hoffenberg (1959): aplicação da regressão à mediana em Economia.
* Koenker e Basset (1978)


---
class: primary
# Estimativas amostrais

```{r}
data.frame(Estimativa = c("Média", "Mediana", "Quantil"),
           `Expressão` = c("\\(\\min_{\\mu \\in \\mathfrak{R}} \\sum (y_i - \\mu)^2\\)",
                           "\\(\\min_{\\xi \\in \\mathfrak{R}} \\sum|y_i - \\xi|\\)",
                           "\\(\\min_{\\xi \\in \\mathfrak{R}} \\sum \\rho_\\tau (y_i - \\xi)\\)")
           ) %>%
  knitr::kable(format = "html", escape = FALSE)
```

---
class: primary

## Função de perda ou de custo

.center2[
![](https://i.stack.imgur.com/DmKq7.png)
]

---
class: primary

## Funções para quantis variados

```{r quantis, fig.height=3.5, dev='svg'}
x <- seq(-2, 2, length=200)
`.1` <- tilted.abs(x, tau=0.1)
`.25` <- tilted.abs(x, tau=0.25)
`.5` <- tilted.abs(x, tau=0.5)
`.75` <- tilted.abs(x, tau=0.75)
`.9` <- tilted.abs(x, tau=0.9)
dados <- as.data.frame(cbind(x, `.1`, `.25`, `.5`, `.75`, `.9`))
dados <- gather(dados, "tau", y, -x)
ggplot(dados, aes(x = x, y = y, colour = tau)) + 
  geom_line() +
  ylab(bquote(rho[tau] ~ (epsilon))) +
  xlab(bquote(epsilon)) +
  guides(colour=guide_legend(title=bquote(tau)))
```

---
class: primary

## Regressão Linear vs. Quantílica

$$\min_{\mu \in \mathfrak{R}^p} \sum  (y_i - \mu(x_i, \beta))^2 $$

$$\min_{\xi \in \mathfrak{R}^p } \sum \rho_\tau (y_i - \xi(x_i, \beta))$$
$$\text{Escolhe-se} \qquad \hat\beta (\tau) \quad | \quad \text{res} \left\{\begin{matrix}
\tau n > 0\\ 
(1-\tau)n <0
\end{matrix}\right.$$

---
class: primary

## RQ - duas dimensões

```{r qr1, fig.height=3.5, dev='svg'}
dados <- centro_2015@data
dados$padrao <- as.numeric(dados$padrao)
qs <- 1:9/10
qr <- rq(valor ~ area_total, data = dados, tau = qs)
ggplot(dados, aes(area_total, valor)) + 
  geom_point() + 
  geom_quantile(quantiles = qs) + 
  geom_smooth(method="lm", se = FALSE, level = .80, color = "red")
```

---
class:primary

```{r}
fit1 <- rq(valor ~ area_total, data = dados, tau = 0.1)
fit_data <- augment(fit1)
# library(gghighlight)
# gghighlight_point(fit_data, aes(x=area_total, y=valor), .resid < 0, col="red") + 
#   geom_quantile(quantile = .1)
p1 <- ggplot(fit_data, aes(x = area_total, y = valor)) +
  geom_quantile(quantiles = 0.1) +
  geom_point(aes(x = area_total, y = valor, colour = .resid > 0)) + 
  labs(title = expression(~tau~'= .1'))
fit2 <- rq(valor ~ area_total, data = centro_2015, tau = 0.2)
fit_data <- augment(fit2)
p2 <- ggplot(fit_data, aes(x = area_total, y = valor)) +
  geom_quantile(quantiles = 0.2) +
  geom_point(aes(x = area_total, y = valor, colour = .resid > 0)) + 
  labs(title = expression(~tau~'= .2'))
fit3 <- rq(valor ~ area_total, data = centro_2015, tau = 0.5)
fit_data <- augment(fit3)
p3 <- ggplot(fit_data, aes(x = area_total, y = valor)) +
  geom_quantile(quantiles = 0.5) +
  geom_point(aes(x = area_total, y = valor, colour = .resid > 0)) + 
  labs(title = expression(~tau~'= .5'))
fit4 <- rq(valor ~ area_total, data = centro_2015, tau = 0.8)
fit_data <- augment(fit4)
p4 <- ggplot(fit_data, aes(x = area_total, y = valor)) +
  geom_quantile(quantiles = 0.8) +
  geom_point(aes(x = area_total, y = valor, colour = .resid > 0)) + 
  labs(title = expression(~tau~'= .8'))
fit5 <- rq(valor ~ area_total, data = centro_2015, tau = 0.9)
fit_data <- augment(fit5)
p5 <- ggplot(fit_data, aes(x = area_total, y = valor)) +
  geom_quantile(quantiles = 0.9) +
  geom_point(aes(x = area_total, y = valor, colour = .resid >= 0)) + 
  labs(title = expression(~tau~'= .9'))
legend_b <- get_legend(
  p1 + 
    guides(color = guide_legend(nrow = 1)) +
    theme(legend.position = "bottom")
)
```

```{r residuos_quantis, fig.height=4.5, dev='svg'}
plot_rows <- plot_grid(p1 + theme(legend.position="none"),
          p2 + theme(legend.position="none"), 
          p3 + theme(legend.position="none"), 
          p4 + theme(legend.position="none"), 
          p5 + theme(legend.position="none"), 
          nrow = 2,
          legend_b)
# now add the title
theme_georgia <- function(...) {
  theme_gray(base_family = "Georgia", ...) + 
    theme(plot.title = element_text(face = "bold"))
}
title <- ggplot() + 
  labs(title = "Regressão para quantis variados", 
       subtitle = "50 dados de apartamentos no centro de Florianópolis (2015)") + 
  theme_georgia()
plot_grid(
  title, plot_rows,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)
```


---
class: primary

## Análise dos coeficientes da RQ

```{r coef1, fig.height=3.5, dev='svg'}
plot(summary(qr), parm="area_total")
```

---
class: primary

# Solução não-única

---
class: primary

```{r exemplo_1, fig.height=4, dev ='svg', fig.cap='Fonte: https://tinyurl.com/y6283end', results='hide'}
par(bg = "light blue")
x <- rep(1:10, each=2)
y <- x/10 + 0:1
plot(x,y, pch = 21, bg = 'grey', main = 'Dados Inventados')

sad <- function(x,y,coef) { # mad is sad/n
    yhat <- coef[1] + coef[2]*x
    resid <- y - yhat
    sum( abs( resid ) )
}
fit <- lm(y~x)
abline(fit, col = "red", lwd = 2)

fit0 <- rq(y~x)
abline(fit0)

fit1 <- lm( y~x, subset= c(1,20) )
fit2 <- lm( y~x, subset= c(2,19) )
fit3 <- lm( y~x, subset= c(2,20) )
fit4 <- lm( y~x, subset= c(1,19) )

fit5.coef <- c(0.5, 1/10)

abline(fit1)
abline(fit2)
abline(fit3)
abline(fit4)
abline(fit5.coef)
for (i in seq( -0.5, 0.5, by=0.1 ) ) {
    abline( fit5.coef + c(i,0) )
}

tmp1 <- seq( coef(fit1)[1], coef(fit2)[1], len=10 )
tmp2 <- seq( coef(fit1)[2], coef(fit2)[2], len=10 )

for (i in seq_along(tmp1) ) {
    abline( tmp1[i], tmp2[i] )
}

sad(x,y, coef(fit0))
sad(x,y, coef(fit1))
sad(x,y, coef(fit2))
sad(x,y, coef(fit3))
sad(x,y, coef(fit4))
sad(x,y, fit5.coef )

for (i in seq( -0.5, 0.5, by=0.1 ) ) {
    print(sad(x,y, fit5.coef + c(i,0) ))
}

for (i in seq_along(tmp1) ) {
    print(sad(x,y, c(tmp1[i], tmp2[i]) ) )
}
```

---
class: primary

```{r exemplo_2, fig.height=4, dev ='svg', fig.cap='Fonte: https://tinyurl.com/y6283end', results='hide'}
# Exemplo 2
set.seed(1)
par(bg = "light blue")
y2 <- y + rnorm(20,0,0.25)
plot(x,y2, pch = 21, bg = 'grey', main = 'Dados aleatórios')
fitnew <- rq(y2~x)  # note the still non-unique warning
abline(fitnew)
abline(coef(fitnew) + c(.1,0))
abline(coef(fitnew) + c(0, 0.01) )
sad( x,y2, coef(fitnew) )
sad( x,y2, coef(fitnew)+c(.1,0))
sad( x,y2, coef(fitnew)+c(0,0.01))
```

---
class: primary

## Vantagens e desvantagens

| Mínimos Quadrados Ordinários      |	Mínimos Resíduos Absolutos           |
|:----------------------------------|:-------------------------------------|
| Não muito robusto                 | Robusto                              |
| Solução Estável	                  | Solução instável e iterativa         |
| Solução única     	              | Possíveis múltiplas soluções         |
| BLUE                              | Não-linear                           |

---
class: primary

## Problemas de convergência 

.center2[
![](https://miro.medium.com/max/1050/1*JTC4ReFwSeAt3kvTLq1YoA.png)
]

---
class: primary

## Outras funções de perda 

.center2[
![](https://miro.medium.com/max/720/1*BploIBOUrhbgdoB1BK_sOg.png)
]




---
class: primary

## Heteroscedasticidade e não-normalidade

.center2[
![](https://miro.medium.com/max/856/1*h_iOn3gSUa2bk6o0foudDA.png)
]

---
class: primary

## Transformações

```{r qr2, fig.height=3.5, dev='svg'}
qs <- 1:9/10
qr2 <- rq(log(valor) ~ log(area_total), data = dados, tau = qs)
ggplot(dados, aes(log(area_total), log(valor))) + 
  geom_point() + 
  geom_quantile(quantiles = qs) + 
  geom_smooth(method="lm", se = FALSE, color = "red")
```

---
class: primary, center, middle

## RQ em $p$ dimensões

---
class: center, middle

```{r}
fit <- lm(log(valor) ~ area_total + quartos + suites + garagens + 
            log(dist_b_mar) + rec(padrao), data = dados,
          subset = -c(31, 39))
fit_1 <- rq(log(valor) ~ area_total + quartos + suites + garagens + 
            log(dist_b_mar) + rec(padrao), data = dados)
fit_2 <- rq(log(valor) ~ area_total + quartos + suites + garagens +
            log(dist_b_mar) + rec(padrao), data = dados, tau = .1)
fit_3 <- rq(log(valor) ~ area_total + quartos + suites + garagens +
            log(dist_b_mar) + rec(padrao), data = dados, tau = .9)
fit_qr <- rq(log(valor) ~ area_total + quartos + suites + garagens + 
            log(dist_b_mar) + rec(padrao), data = dados, tau = qs)
```

```{r coefs, out.width = "100%", fig.height=4.5, dev='svg'}
plot(summary(fit_qr))
```

---
class: primary

## Predições

```{r}
p <- predict(fit, newdata = dados[52,], interval = "confidence", level = .80)
pp <- predict(fit, newdata = dados[52,], interval = "prediction", level = .80)
p1 <- predict(fit_1, newdata = dados[52,], interval = "confidence", level = .80)
p2 <- predict(fit_2, newdata = dados[52,], interval = "confidence", level = .80)
p3 <- predict(fit_3, newdata = dados[52,], interval = "confidence", level = .80)
P <- brformat(exp(p))
PP <- brformat(exp(pp))
P1 <- brformat(exp(p1))
P2 <- brformat(exp(p2))
P3 <- brformat(exp(p3))
```

|                      | 10%           | 50% ou média  | 90%           | 
|:---------------------|--------------:|--------------:|--------------:|
| Regressão linear (IP)|`r PP[, "lwr"]`|`r PP[, "fit"]`|`r PP[, "upr"]`|
| Regressão quantílica |`r P2[, "fit"]`|`r P1[, "fit"]`|`r P3[, "fit"]`|

